Data structure: Each object has a class. The parameters that belong to each class will be the keys to a dictionary, and the corresponding 
value will be the value.

testing:
1)what happens when r_vec = 0?
2)what if the user gives bad input?
	negative vectors
	strings

pseudocode

import numpy as np

make classes with geometric, position, and charge information, as well as how the Efield and V vary as a function of position.




Classes ARE things and they HAVE things.

top level: generic class called charged_object
	all have a center point. This will be inherited by all sub classes

next level: a sub class based on geometry of the shape



class charged=object(object):
	def __init__(self,pos):                   pos is position. A charged object cannot be created without having a center position

class charged_sphere(charged_object):
	def __init__(self,pos,radius)
		self.pos = pos
		self.rad = radius



.
.
.
Class A has a ton of stuff
	also has E-Field(self,pos)
Class B 
...
def E_field(self, pos)





Move each of my functions into the classes after changing their names to E_field. don't make them distinct.
